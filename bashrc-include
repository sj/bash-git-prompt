# vim: set filetype=bash

# Determines if a directory ($1) is local to this system.
function bgp_is_local_directory(){
	LOCAL_FSTYPES="ext2 ext3"

	dir="$1"
	mountpoint=""
	mountpoint_fs=""
	for mountinfo in $(mount | grep ^/dev | sed "s/ on /|/g" | sed "s/ type /|/g" | sed "s/ (/|(/g"); do 
		this_mountdev=`echo $mountinfo | cut -d "|" -f 1`
		this_mountpoint=`echo $mountinfo | cut -d "|" -f 2`
		this_mountfstype=`echo $mountinfo | cut -d "|" -f 3`

		result=($(echo "$dir" | grep -o "$this_mountpoint"))
		if [[ ${#result} -gt ${#mountpoint} ]]; then
			mountpoint="$result"
			mountpoint_fs="$this_mountfstype"
		fi
	done

	if [ "$mountpoint_fs" = "" ]; then
		# Can't find mount point
		bgp_log "can't figure out whether '$dir' is local to this system"
		echo "yes"
		return
	fi

	for local_fstype in $LOCAL_FSTYPES; do
		if [ "$local_fstype" = "$mountpoint_fs" ]; then
			bgp_log "repository at '$dir' is located on mount point '$mountpoint' which is of local type '$local_fstype'"
			echo "yes"
			return
		fi
	done


	bgp_log "repository at '$dir' is located on mount point '$mountpoint', which is of non-local filesystem type '$mountpoint_fs'"
	echo "no"
}


function bgp_clean_instances(){
	if [ ! -d "$RUNDIR/instances" ]; then
		mkdir -p "$RUNDIR/instances"
	fi

	cd "$RUNDIR/instances" || return
	bgp_log "Cleaning garbage from previous instances:"

	ls | while read instance_pid; do
		proc_cmdline="/proc/$instance_pid/cmdline"
		if [ ! -r "$proc_cmdline" ] || [ "`cat $proc_cmdline | grep bash`" = "" ]; then
			bgp_log "PID $instance_pid no longer active, cleaning up"
			rm -rf "$RUNDIR/instances/$instance_pid"
		else
			bgp_log "PID $instance_pid currently active, not cleaning up"
		fi
	done	
	
	# Back to home dir
	cd
}
	
function bgp_log(){
	echo "`date` -- $BASH_GIT_PROMPT_PID -- $@" >> /tmp/bash-git-prompt.log
}

function bgp_make_prompt_label() {
	INSTANCE_RUNDIR="$RUNDIR/instances/$BASH_GIT_PROMPT_PID"

	if [ -f "$INSTANCE_RUNDIR/disabled" ]; then
		return
	fi

	currdir=`pwd`
	currdir_hash=`bgp_hash "$currdir"`

	repo_root=""
	currdir_cache_file="$RUNDIR/cache/directories/$currdir_hash"
	if [ ! -r "$currdir_cache_file" ]; then
		bgp_log "no information known for '$currdir' ($currdir_cache_file does not exist)"

		# No cache information known for current directory - create it.
		mkdir -p "$RUNDIR/cache/directories"

		repo_root=`git rev-parse --show-toplevel 2> /dev/null`
		if [ "$repo_root" = "" ]; then
			# Current pwd is not part of repository - construct empty file
			bgp_log "current directory not part of Git repository"
			touch "$currdir_cache_file"
		else
			bgp_log "current directory part of Git repository at '$repo_root', storing in cache"
			echo "$repo_root" > "$currdir_cache_file"
		fi
	else
		bgp_log "found cache for '$currdir': $currdir_cache_file"

		repo_root=`cat "$currdir_cache_file"`
		if [ "$repo_root" = "" ]; then
			bgp_log "information in cache about '$currdir': not part of Git repository"
		else
			bgp_log "information in cache about '$currdir': part of Git repository at '$repo_root'"
		fi
	fi
	
	if [ ! "$repo_root" = "" ]; then
		# There is a repository root - query cache for more info
		repo_root_hash=`bgp_hash "$repo_root"`
		repo_cache_file="$RUNDIR/cache/repositories/$repo_root_hash"


		bgp_log "reading cache for repository root '$repo_root' ($repo_cache_file)"
		repo_is_local=`bgp_is_local_directory "$repo_root"`

		repo_cache_file_age_str=""
		force_git_refresh="no"
		if [ -r "$repo_cache_file" ]; then
			# Check age of cache
			now=`date +%s`
			lastmod=`stat -c %Y "$repo_cache_file"`
			age_secs=$((now-lastmod))
			
			if [ "$age_secs" -lt "30" ]; then
				bgp_log "cache is only $age_secs seconds old - not refreshing"
			elif [ "$repo_is_local" = "yes" ]; then
				bgp_log "forcing refresh of cached Git repository information (on local filesystem): older than 30 seconds ($age_secs seconds)"
				force_git_refresh="yes"
			elif [ "$repo_is_local" = "no" ]; then
				bgp_log "not refreshing cached Git repository information: repository is not on a local filesystem (cache age: $age_secs seconds)"
			fi
		fi

		if [ "$force_git_refresh" = "no" ]; then
			# Check whether recent history contains a reason to refresh cache
			history_git=`history | tail -n1 | grep "git commit\|git push\|git pull\|git mytest\|git fetch"`
			history_last=`history | tail -n1`

			bgp_log "last entry in Bash history: '$history_last'"
		
			if [ ! "$history_git" = "" ]; then
				bgp_log "forcing Git refresh because of recent history"
				force_git_refresh="yes"
			fi
		fi

		if [ ! -r "$repo_cache_file" ] || [ "$force_git_refresh" = "yes" ]; then
			# No cache available yet - construct from git
			bgp_log "querying Git for information regarding repository '$repo_root'"

			if [ ! -d "$RUNDIR/cache/repositories" ]; then
				mkdir -p "$RUNDIR/cache/repositories"
			fi

			parsed_git_info="`parse_git_info`"
			echo "$parsed_git_info" > "$repo_cache_file"
			echo "$parsed_git_info"
		else
			# Read prompt from cache to speed things op
			bgp_log "presenting cache information for repository at '$repo_root' in Bash prompt"
			cat $repo_cache_file
		fi
	fi # else: current dir not part of Git repository
}

function parse_git_info(){
	git_branch=`git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'`
	if [ ! "$git_branch" = "" ]; then
		if [ ! "$git_branch" = "(no branch)" ]; then
			if [ ! "`git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD)`" = "" ]; then
				# Local branch has upstream
				git_num_commits_not_pushed=`git log --oneline @{upstream}.. | wc -l` 
				if [ "$git_num_commits_not_pushed" -gt "0" ]; then
					commits_not_pushed_str=" ↑$git_num_commits_not_pushed"
				fi	
			else
				# Local branch does not have upstream
				git_num_commits_not_pushed=`git show-branch "$git_branch" | wc -l`
				if [ "$git_num_commits_not_pushed" -gt "0" ]; then
					commits_not_pushed_str=" ↑$git_num_commits_not_pushed!"
				fi	
			fi
			git_num_changes_uncommitted=`git status --porcelain | wc -l`
			if [ "$git_num_changes_uncommitted" -gt "0" ]; then
				num_changes_str=" ~$git_num_changes_uncommitted"
			fi
		fi # else: no branch info available (e.g. when rebasing)
		echo " [$git_branch$commits_not_pushed_str$num_changes_str] "
	fi
}

function bgp_hash(){
	echo $@ | md5sum | awk '{print $1}'
}

function proml {
	local        BLUE="\[\033[0;34m\]"
	local         RED="\[\033[0;31m\]"
	local   LIGHT_RED="\[\033[1;31m\]"
	local       GREEN="\[\033[0;32m\]"
	local LIGHT_GREEN="\[\033[1;32m\]"
	local       WHITE="\[\033[1;37m\]"
	local  LIGHT_GRAY="\[\033[0;37m\]"

	case $TERM in
		xterm*)
			TITLEBAR='\[\033]0;\u@\h:\w\007\]'
			;;
		*)
			TITLEBAR=""
			;;
	esac

	#PS1="${TITLEBAR}\u@\h:\w$WHITE\$(parse_git_info) $LIGHT_GRAY> "
	PS1="${TITLEBAR}\u@\h:\w$WHITE\$(bgp_make_prompt_label) $LIGHT_GRAY> "
	PS2='> '
	PS4='+ '
}

RUNDIR="/run/user/$UID/bash-git-prompt"

if [ -z "$BASH_GIT_PROMPT_PID" ]; then
	export BASH_GIT_PROMPT_PID="$BASHPID"
	INSTANCE_RUNDIR="/run/user/$UID/bash-git-prompt/instances/$BASHPID"
	
	bgp_clean_instances
	mkdir -p "$INSTANCE_RUNDIR" &> /dev/null

fi

proml
